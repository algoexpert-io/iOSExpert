1.
import Observation

@Observable
class World {
  var soundPlayer: SoundPlayer = SoundPlayerReal()
  var getterSetter: GetterSetter = GetterSetterReal()
  var breedsURL: BreedsURL = .standard
  var sessionType: SessionType = .shared
}

2.
import Foundation
import Observation

var Current = World.chooseWorld()

@Observable
class World {
  var settings = Settings(getterSetter: GetterSetterFake())
  var soundPlayer: SoundPlayer = SoundPlayerDummy()
  var imageLoader = ImageLoader()

  init(settings: Settings, soundPlayer: SoundPlayer, imageLoader: ImageLoader) {
    self.settings = settings
    self.soundPlayer = soundPlayer
    self.imageLoader = imageLoader
  }

  static func chooseWorld() -> World {
    if NSClassFromString("XCTest") != nil {
      return World.unitTest
    } else {
      return World.production
    }
  }

  static let production: World = {
    let settings = Settings(getterSetter: GetterSetterReal())

    return World(
      settings: settings,
      soundPlayer: SoundPlayerReal(),
      imageLoader: ImageLoader()
    )
  }()

  static let unitTest: World = {
    let settings = Settings(getterSetter: GetterSetterFake())
    settings.sessionType = .stub

    return World(
      settings: settings,
      soundPlayer: SoundPlayerDummy(),
      imageLoader: ImageLoader()
    )
  }()
}

3.
protocol SoundPlayer {
  func play(_ sound: Sound)
}

4.
import AVFoundation

class SoundPlayerReal: SoundPlayer {
  private var sounds: [String: AVAudioPlayer]
  private let soundExtension = "mp3"

  init () {
    sounds = [:]
  }

  func play(_ sound: Sound) {
    if sounds[sound.rawValue] == nil {
      if let audioURL = Bundle.main.url(forResource: sound.rawValue, withExtension: soundExtension) {
        try? sounds[sound.rawValue] = AVAudioPlayer.init(contentsOf: audioURL)
      }
    }

    if let retrievedSound = sounds[sound.rawValue] {
      retrievedSound.play()
    }
  }
}

5.
class SoundPlayerDummy: SoundPlayer {
  func play(_ sound: Sound) {}
}

6.
protocol GetterSetter {
  func get(key: String) -> String?
  func set(key: String, value: String)
}

7.
import Foundation

class GetterSetterReal: GetterSetter {
  func get(key: String) -> String? {
    return UserDefaults.standard.string(forKey: key)
  }

  func set(key: String, value: String) {
    UserDefaults.standard.set(value, forKey: key)
  }
}

8.
class GetterSetterFake: GetterSetter {
  var dictionary: [String: String] = [:]

  init() {}

  init(dictionary: [String: String]) {
    self.dictionary = dictionary
  }

  func get(key: String) -> String? {
    return dictionary[key]
  }

  func set(key: String, value: String) {
    dictionary[key] = value
  }
}

9.
class Settings {
  let getterSetter: GetterSetter

  var breedsURL: BreedsURL {
    didSet {
      if breedsURL != oldValue {
        getterSetter.set(key: Settings.breedsURLKey, value: breedsURL.rawValue)
      }
    }
  }
  static let breedsURLKey = "breedsURL"
  static let breedsURLDefault: BreedsURL = .withMore

  var sessionType: SessionType {
    didSet {
      if sessionType != oldValue {
        getterSetter.set(key: Settings.sessionTypeKey, value: sessionType.rawValue)
//        Task {
//          await Current.imageLoader.setSession(sessionType.session)
//        }
      }
    }
  }
  static let sessionTypeKey = "sessionType"
  static let sessionTypeDefault: SessionType = .shared

  var sortOrder: SortOrder {
    didSet {
      if sortOrder != oldValue {
        getterSetter.set(key: Settings.sortOrderKey, value: sortOrder.rawValue)
      }
    }
  }
  static let sortOrderKey = "sortOrder"
  static let sortOrderDefault: SortOrder = .name

  init(getterSetter: GetterSetter) {
    self.getterSetter = getterSetter

    if let breedsURLString = getterSetter.get(key: Settings.breedsURLKey) {
      breedsURL = BreedsURL(rawValue: breedsURLString) ?? Settings.breedsURLDefault
    } else {
      breedsURL = Settings.breedsURLDefault
      getterSetter.set(key: Settings.breedsURLKey, value: breedsURL.rawValue)
    }

    if let sessionTypeString = getterSetter.get(key: Settings.sessionTypeKey) {
      sessionType = SessionType(rawValue: sessionTypeString) ?? Settings.sessionTypeDefault
    } else {
      sessionType = Settings.sessionTypeDefault
      getterSetter.set(key: Settings.sessionTypeKey, value: sessionType.rawValue)
    }

    if let sortOrderString = getterSetter.get(key: Settings.sortOrderKey) {
      sortOrder = SortOrder(rawValue: sortOrderString) ?? Settings.sortOrderDefault
    } else {
      sortOrder = Settings.sortOrderDefault
      getterSetter.set(key: Settings.sortOrderKey, value: sortOrder.rawValue)
    }
  }
}

10.
import Foundation

enum BreedsURL: String, CaseIterable {
  case standard
  case empty
  case malformed
  case withMore

  var url: URL {
    let standardURLString = "https://assets.algoexpert.io/course-assets/iosexpert/breeds.json"
    let emptyURLString = "https://assets.algoexpert.io/course-assets/iosexpert/breeds_empty.json"
    let malformedURLString = "https://assets.algoexpert.io/course-assets/iosexpert/breeds_malformed.json"
    let withMoreURLString = "https://assets.algoexpert.io/course-assets/iosexpert/breeds_with_more.json"

    let urlString: String

    switch self {
    case .standard:
      urlString = standardURLString
    case .empty:
      urlString = emptyURLString
    case .malformed:
      urlString = malformedURLString
    case .withMore:
      urlString = withMoreURLString
    }

    if let url = URL(string: urlString) {
      return url
    } else {
      fatalError(URL.couldNotInit(urlString: urlString))
    }
  }

  var displayName: String {
    switch self {
    case .standard:
      return "Standard"
    case .empty:
      return "Empty"
    case .malformed:
      return "Malformed"
    case .withMore:
      return "With More"
    }
  }
}

11.
import Foundation

enum SessionType: String, CaseIterable {
  case shared
  case stub

  var session: URLSession {
    switch self {
    case .shared:
      return URLSession.shared
    case .stub:
      return URLSession.stub
    }
  }

  var displayName: String {
    switch self {
    case .shared:
      return "Shared"
    case .stub:
      return "Stub"
    }
  }
}

12.
import Foundation

extension URLSession {
  static var urlDataDict: [URL: Data] = [:]
  static var didProcessURLs = false

  static var stub: URLSession {
    if !didProcessURLs {
      didProcessURLs = true
      BreedsURL.allCases.forEach {
        if let path = Bundle.main.path(forResource: $0.url.lastPathComponent, ofType: nil) {
          do {
            let data = try Data(contentsOf: URL(fileURLWithPath: path))
            URLSession.urlDataDict[$0.url] = data
          } catch {
            fatalError("Unable to load mock JSON data for URL \($0.url).")
          }
        }
      }

      for breedName in MockData.breedNames {
        if
          let bundleUrl = Bundle.main.url(forResource: breedName, withExtension: MockData.mockPhotoExtension),
          let actualUrl = URL(string: "\(MockData.photoUrlPrefix)\(breedName)\(MockData.mockPhotoExtension)")
        {
          do {
            let data = try Data(contentsOf: bundleUrl)
            URLSession.urlDataDict[actualUrl] = data
          } catch {
            fatalError("Unable to initialize Data.")
          }
        } else {
          fatalError("Unable to construct path to \(breedName).\(MockData.mockPhotoExtension).")
        }
      }
    }

    let config = URLSessionConfiguration.ephemeral
    config.protocolClasses = [URLProtocolStub.self]
    return URLSession(configuration: config)
  }
}

13.
enum MockData {
  static let mockPhotoExtension = ".jpg"
  static let photoUrlPrefix = "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/"

  static let breedNames: [String] = [
    "Abyssinian",
    "Balinese",
    "Bengal",
    "Burmese",
    "CloudedLeopard",
    "DevonRex",
    "EuropeanWildcat",
    "MaineCoon",
    "Manx",
    "Ragdoll",
    "RussianBlue",
    "Sand",
    "Savannah",
    "Serval",
    "Siamese",
    "Smilodon",
    "Tonkinese",
    "TurkishAngora",
    "Van"
  ]
}

14.
import Foundation

class URLProtocolStub: URLProtocol {
  override class func canInit(with request: URLRequest) -> Bool {
    true
  }

  override class func canonicalRequest(for request: URLRequest) -> URLRequest {
    request
  }

  override func startLoading() {
    if
      let url = request.url,
      let data = URLSession.urlDataDict[url]
    {
      client?.urlProtocol(self, didReceive: URLResponse(), cacheStoragePolicy: .notAllowed)
      client?.urlProtocol(self, didLoad: data)
    } else {
      client?.urlProtocol(self, didFailWithError: LoadingError.loadFailed)
    }
    client?.urlProtocolDidFinishLoading(self)
  }

  override func stopLoading() {}

  enum LoadingError: Error {
    case loadFailed
  }
}

15.
class ImageLoader {}

16.
@Bindable private var current = Current

17.
Picker("", selection: $current.settings.sortOrder) {

18.
Current.soundPlayer.play

19.
let (data, _) = try await Current.settings.sessionType.session.data(from: Current.settings.breedsURL.url)

20.
import UIKit

actor ImageLoader {
  private var session = URLSession.shared
  private var loaderStatuses: [URL: LoaderStatus] = [:]

  private enum LoaderStatus {
    case inProgress(Task<UIImage, Error>)
    case fetched(UIImage)
  }

  func fetch(_ url: URL) async -> UIImage {
    let errorImage = UIImage(resource: .error)

    if let status = loaderStatuses[url] {
      switch status {
      case .fetched(let image):
        return image
      case .inProgress(let task):
        return (try? await task.value) ?? errorImage
      }
    }

    let task: Task<UIImage, Error> = Task {
      let image: UIImage

      do {
        let (imageData, _) = try await session.data(from: url)
        let imageFromNetwork = UIImage(data: imageData)
        image = imageFromNetwork ?? errorImage
      } catch {
        image = errorImage
      }

      return image
    }

    loaderStatuses[url] = .inProgress(task)

    do {
      let image = try await task.value
      loaderStatuses[url] = .fetched(image)
      return image
    } catch {
      loaderStatuses[url] = .fetched(errorImage)
      return errorImage
    }
  }

  func setSession(_ session: URLSession) async {
    self.session = session
  }
}

21.
@State private var images: [Breed: UIImage] = [:]

22.
func list(of breeds: [Breed]) -> some View {
  List(breeds) { breed in
    NavigationLink {
      BreedDetailsView(breed: breed)
    } label: {
      HStack {
        VStack(alignment: .leading) {
          Text(breed.name)
            .font(.headline)
          Text(breed.knownFor)
          Text("Popularity: \(breed.popularity)")
        }

        Spacer()

        Group {
          if let image = images[breed] {
            Image(uiImage: image)
              .resizable()
              .aspectRatio(contentMode: .fit)
              .padding()
          } else {
            ProgressView()
          }
        }
        .frame(width: photoHeightWidth)
        .task {
          await images[breed] = Current.imageLoader.fetch(breed.photoUrl)
        }
      }
      .padding()
    }
  }
}

23.
@State private var image: UIImage?

24.
Group {
  if let image {
    Image(uiImage: image)
      .resizable()
      .aspectRatio(contentMode: .fit)
      .padding()
  } else {
    ProgressView()
  }
}
.frame(width: photoHeightWidth, height: photoHeightWidth)
.task {
  await image = Current.imageLoader.fetch(breed.photoUrl)
}

25.
import SwiftUI

extension View {
  func segmentedPicker() -> some View {
    modifier(SegmentedPicker())
  }
}

private struct SegmentedPicker: ViewModifier {
  func body(content: Content) -> some View {
    content
      .pickerStyle(SegmentedPickerStyle())
      .padding(.horizontal, Layout.doubleStandard)
  }
}

26.
import SwiftUI

struct SettingsView: View {
  @Bindable private var current = Current

  var body: some View {
    ScrollView(.vertical) {
      Text("Settings")
        .font(.largeTitle)

      Spacer()
        .frame(height: Layout.tripleStandard)

      Group {
        Text("Breeds URL")
          .font(.title)

        Picker("", selection: $current.settings.breedsURL) {
          ForEach(BreedsURL.allCases, id: \.self) { breedsURL in
            Text(breedsURL.displayName).tag(breedsURL)
          }
        }
        .segmentedPicker()

        Text("This setting controls the URL of the JSON file that the breeds-browsing screen retrieves. Revisit that screen after changing this setting to initiate another API call.")
          .padding()
      }

      Group {
        Text("URLSession Type")
          .font(.title)

        Picker("", selection: $current.settings.sessionType) {
          ForEach(SessionType.allCases, id: \.self) { sessionType in
            Text(sessionType.displayName).tag(sessionType)
          }
        }
        .segmentedPicker()

        Text("This setting controls which URLSession to use for JSON retrieval and image fetching: shared or stub.")
          .padding()
      }

      Group {
        Text("Sort Order")
          .font(.title)

        Picker("", selection: $current.settings.sortOrder) {
          ForEach(SortOrder.allCases, id: \.self) { sortOrder in
            Text(sortOrder.displayName).tag(sortOrder)
          }
        }
        .segmentedPicker()

        Text("This setting controls the sort order of breeds on KatFancy's breed-browsing screen.")
          .padding()
      }

      Spacer()
    }
  }
}

27.
static var breed: Breed {
  Breed(
    name: "Clouded Leopard",
    knownFor: "climbing ability",
    popularity: 17,
    photoUrl: URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/CloudedLeopard.jpg")!,
    infoUrl: URL(string: "https://en.wikipedia.org/wiki/Clouded_leopard")!,
    credit: "Trisha Shears",
    license: .cc3,
    description: "The clouded leopard (Neofelis nebulosa), also called the mainland clouded leopard, is a wild cat inhabiting dense forests from the foothills of the Himalayas through mainland Southeast Asia into South China. In the early 19th century, a clouded leopard was brought to London from China and described in 1821. It has large dusky-grey blotches and irregular spots and stripes reminiscent of clouds. Its head-and-body length ranges from 68.6 to 108 cm (27.0 to 42.5 in) with a 61 to 91 cm (24 to 36 in) long tail. It uses its tail for balancing when moving in trees and is able to climb down vertical tree trunks head first. It rests in trees during the day and hunts by night on the forest floor.\n\nThe clouded leopard is the first cat that genetically diverged 9.32 to 4.47 million years ago from the common ancestor of the pantherine cats. Today, the clouded leopard is locally extinct in Singapore, Taiwan, and possibly Hainan Island and Vietnam. Its total population is suspected to be fewer than 10,000 mature individuals, with a decreasing population trend, and no single population numbering more than 1,000 adults. It has therefore been listed as Vulnerable on the IUCN Red List since 2008. The population is threatened by large–scale deforestation and commercial poaching for the wildlife trade. Its body parts are offered for decoration and clothing, though it is legally protected in most range countries.\n\nThe clouded leopard has been kept in zoological gardens since the early 20th century. Captive breeding programs were initiated in the 1980s. In captivity, the clouded leopard has an average lifespan of 11 years.\n\nThe clouded leopard's fur is of a dark grey or ochreous ground-color, often largely obliterated by black and dark dusky-grey blotched pattern. There are black spots on the head, and the ears are black. Partly fused or broken-up stripes run from the corner of the eyes over the cheek, from the corner of the mouth to the neck, and along the nape to the shoulders. Elongated blotches continue down the spine and form a single median stripe on the loins. Two large blotches of dark dusky-grey hair on the side of the shoulders are each emphasized posteriorly by a dark stripe, which passes on to the foreleg and breaks up into irregular spots. The flanks are marked by dark dusky-grey irregular blotches bordered behind by long, oblique, irregularly curved or looped stripes. These blotches yielding the clouded pattern suggest the English name of the cat. The underparts and legs are spotted, and the tail is marked by large, irregular, paired spots. Its legs are short and stout, and paws broad. Females are slightly smaller than males."
  )
}

static var breeds: [Breed] {
  [
    MockData.breed,
    Breed(
      name: "European Wildcat",
      knownFor: "warm coat",
      popularity: 19,
      photoUrl: URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/EuropeanWildcat.jpg")!,
      infoUrl: URL(string: "https://en.wikipedia.org/wiki/European_wildcat")!,
      credit: "Tambako The Jaguar",
      license: .ccnd2,
      description: "The European wildcat (Felis silvestris) is a small wildcat species native to continental Europe, Scotland, Turkey and the Caucasus. It inhabits forests from the Iberian Peninsula, Italy, Central and Eastern Europe to the Caucasus. Its fur is brownish to grey with stripes on the forehead and on the sides and has a bushy tail with a black tip. It reaches a head-to-body length of up to 65 cm (26 in) with a 34.5 centimetres (13.6 in) long tail, and weighs up to 7.5 kg (17 lb).\n\nIn France and Italy, the European wildcat is predominantly nocturnal, but also active in the daytime when undisturbed by human activities. It preys foremost on small mammals such as lagomorphs and rodents, but also on ground-dwelling birds.\n\nThe European wildcat's fur varies in colour from brownish to grey with paler contour hairs. It has five stripes on the forehead, which are broken up into small spots. A dark stripe behind the shoulders expands into a spinal stripe running up to the base of the tail. On the sides, it has irregular dark stripes, which break up on the hind legs, thus forming a blotched pattern. Its tail is bushy with two to three black, transverse rings and rounded at the black tip.\n\nThe top of the head and the forehead bear four well-developed dark bands that split into small spots. Two short and narrow stripes are usually present in the shoulder region, in front of the dorsal band. Some individuals have a few light spots on the throat, between the forelegs, or in the inguinal region. The dorsal surface of the neck and head are the same colour as that of the trunk, but is lighter grey around the eyes, lips, cheeks, and chin. A slight ochreous shade is visible on the undersides of the flanks."
    ),
    Breed(
      name: "Sand Cat",
      knownFor: "sad face",
      popularity: 21,
      photoUrl: URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/Sand.jpg")!,
      infoUrl: URL(string: "https://en.wikipedia.org/wiki/Sand_cat")!,
      credit: "Clément Bardot",
      license: .cc4,
      description: "The sand cat (Felis margarita) is a small wild cat that inhabits sandy and stony deserts far from water sources. With its sandy to light grey fur, it is well camouflaged in a desert environment. Its head-and-body length ranges from 39–52 cm (15–20 in) with a 23–31 cm (9.1–12.2 in) long tail. Its 5–7 cm (2.0–2.8 in) short ears are set low on the sides of the head, aiding detection of prey moving underground. The long hair covering the soles of its paws insulates its pads against the extremely hot and cold temperatures in deserts.\n\nThe first sand cat known to science was discovered in the Algerian Sahara and described in 1858. To date, it has been recorded in several disjunct locations in Morocco, Algeria, Niger, Chad, Egypt, the Arabian Peninsula and the Middle East. In Central Asia, it was first recorded in the Karakum Desert in 1925. The large gap between these two regions of its global range was partially closed in 1948, when a sand cat skin was found in an oasis of the Rub' al Khali in Oman. It is discontinuously distributed in the deserts of the Arabian Peninsula and the Middle East. In the early 1970s, sand cats were caught in southwestern Pakistan and exported to zoos worldwide. Due to its wide distribution and large population, it is listed as Least Concern on the IUCN Red List.\n\nThe sand cat usually rests in underground dens during the day and hunts at night. It moves 5.4 km (3.4 mi) on average at night in search of small rodents and birds. Among the Tuareg people of the Ténéré desert, it has a reputation of efficiently killing venomous snakes. In spring, the female gives birth to two to three kittens, which become sexually mature around the age of one year. The sand cat's ecological requirements are still poorly understood, as only a few in-depth studies targeting wild sand cat populations have been conducted."
    ),
    Breed(
      name: "Serval",
      knownFor: "jumping ability",
      popularity: 39,
      photoUrl: URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/Serval.jpg")!,
      infoUrl: URL(string: "https://en.wikipedia.org/wiki/Serval")!,
      credit: "Lilla Frerich",
      license: .publicDomain,
      description: "The serval is a wild cat native to Africa. It is rare in North Africa and the Sahel, but widespread in sub-Saharan countries, except rainforest regions. Across its range, it occurs in protected areas, and hunting it is either prohibited or regulated in range countries.\n\nIt is the sole member of the genus Leptailurus. Three subspecies are recognised. The serval is a slender, medium-sized cat that stands 54–62 cm (21–24 in) at the shoulder and weighs 9–18 kg (20–40 lb). It is characterised by a small head, large ears, a golden-yellow to buff coat spotted and striped with black, and a short, black-tipped tail. The serval has the longest legs of any cat relative to its body size.\n\nThe serval is a solitary carnivore and active both by day and at night. It preys on rodents, particularly vlei rats, small birds, frogs, insects, and reptiles, using its sense of hearing to locate prey. It leaps over 2 m (6 ft 7 in) above the ground to land on the prey on its forefeet, and finally kills it with a bite on the neck or the head. Both sexes establish highly overlapping home ranges of 10 to 32 km2 (4 to 12 sq mi), and mark them with feces and saliva. Mating takes place at different times of the year in different parts of their range, but typically once or twice a year in an area. After a gestational period of two to three months, a litter of one to four is born. The kittens are weaned at the age of one month and begin hunting on their own at six months of age. They leave their mother at the age of around 12 months."
    ),
    Breed(
      name: "Smilodon",
      knownFor: "resistance to house training",
      popularity: 22,
      photoUrl: URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/CatImages/Smilodon.jpg")!,
      infoUrl: URL(string: "https://en.wikipedia.org/wiki/Smilodon")!,
      credit: "Vitor vacs",
      license: .pinterest,
      description: "Smilodon is a genus of the extinct machairodont subfamily of the felids. It is one of the most famous prehistoric mammals and the best known saber-toothed cat. Although commonly known as the saber-toothed tiger, it was not closely related to the tiger or other modern cats. Smilodon lived in the Americas during the Pleistocene epoch (2.5 mya – 10,000 years ago). The genus was named in 1842 based on fossils from Brazil; the generic name means \"scalpel\" or \"two-edged knife\" combined with \"tooth\". Three species are recognized today: S. gracilis, S. fatalis, and S. populator. The two latter species were probably descended from S. gracilis, which itself probably evolved from Megantereon. The hundreds of individuals obtained from the La Brea Tar Pits in Los Angeles constitute the largest collection of Smilodon fossils.\n\nOverall, Smilodon was more robustly built than any extant cat, with particularly well-developed forelimbs and exceptionally long upper canine teeth. Its jaw had a bigger gape than that of modern cats, and its upper canines were slender and fragile, being adapted for precision killing. S. gracilis was the smallest species at 55 to 100 kg (120 to 220 lb) in weight. S. fatalis had a weight of 160 to 280 kg (350 to 620 lb) and height of 100 cm (39 in). Both of these species are mainly known from North America, but remains from South America have also been attributed to them. S. populator from South America was the largest species, at 220 to 436 kg (485 to 961 lb) in weight and 120 cm (47 in) in height, and was among the largest known felids. The coat pattern of Smilodon is unknown, but it has been artistically restored with plain or spotted patterns.\n\nIn North America, Smilodon hunted large herbivores such as bison and camels, and it remained successful even when encountering new prey species in South America. Smilodon is thought to have killed its prey by holding it still with its forelimbs and biting it, but it is unclear in what manner the bite itself was delivered. Scientists debate whether Smilodon had a social or a solitary lifestyle; analysis of modern predator behavior as well as of Smilodon's fossil remains could be construed to lend support to either view. Smilodon probably lived in closed habitats such as forests and bush, which would have provided cover for ambushing prey. Smilodon died out at the same time that most North and South American megafauna disappeared, about 10,000 years ago. Its reliance on large animals has been proposed as the cause of its extinction, along with climate change and competition with other species, but the exact cause is unknown."
    )
  ]
}

28.
func loadBreeds(mockedState: State? = nil) async {
  if let mockedState {
    self.state = mockedState
  } else {
    state = .loading
    do {
      var breeds = try await BreedsLoader.loadBreeds()
      breeds.sort { breed1, breed2 in
        Current.settings.sortOrder.compare(breed1: breed1, breed2: breed2)
      }
      state = .loaded(breeds: breeds)
    } catch {
      state = .error
    }
  }

  switch state {
  case .loading:
    break
  case .loaded(breeds: let breeds):
    if breeds.isEmpty {
      Current.soundPlayer.play(.sadTrombone)
    } else {
      Current.soundPlayer.play(.chime)
    }
  case .error:
    Current.soundPlayer.play(.sadTrombone)
  }
}

29.
private let mockedState: BrowseBreedsViewModel.State?

30.
init(mockedState: BrowseBreedsViewModel.State? = nil) {
  self.mockedState = mockedState
}

31.
await viewModel.loadBreeds(mockedState: mockedState)

32.
#Preview("Mocked Data") {
  BrowseBreedsView(mockedState: .loaded(breeds: MockData.breeds))
}

#Preview("Actual Data") {
  BrowseBreedsView()
}

#Preview("No Data") {
  BrowseBreedsView(mockedState: .loaded(breeds: []))
}

#Preview("Error") {
  BrowseBreedsView(mockedState: .error)
}

#Preview("Loading") {
  BrowseBreedsView(mockedState: .loading)
}

33.
#Preview {
  NavigationStack {
    BreedDetailsView(breed: MockData.breed)
  }
}

34.
#Preview {
  ErrorRetryView(message: "This is a test error message.", viewModel: BrowseBreedsViewModel())
}

35.
#Preview {
  MainTabView()
}

36.
private struct SegmentedPickerView: View {
  @State var selection = BreedsURL.withMore

  var body: some View {
    VStack {
      Text("segmentedPicker()")
        .font(.headline)

      Picker("", selection: $selection) {
        ForEach(BreedsURL.allCases, id: \.self) { breedsURL in
          Text(breedsURL.displayName)
        }
      }
      .segmentedPicker()
    }
  }
}

#Preview {
  SegmentedPickerView()
}

37.
#Preview {
  SettingsView()
}

38.
import SwiftUI

struct KatFancyTestApp: App {
  var body: some Scene {
    WindowGroup {
      VStack {
        Text("Running Unit Tests")
          .font(.largeTitle)
        ProgressView()
      }
    }
  }
}

39.
import SwiftUI

@main
struct AppLauncher {
  static func main() throws {
    if NSClassFromString("XCTestCase") == nil {
      KatFancyApp.main()
    } else {
      KatFancyTestApp.main()
    }
  }
}

40.
@testable import KatFancy
import XCTest

class BreedsLoaderTests: XCTestCase {
  func testLoadBreeds() async throws {
    Current.settings.breedsURL = .withMore
    let breeds = try await BreedsLoader.loadBreeds()
    let expectedCount = MockData.breedNames.count
    XCTAssertEqual(expectedCount, breeds.count)
  }
}

41.
@testable import KatFancy
import XCTest

class GetterSetterFakeTests: XCTestCase {
  func testGetAndSet() {
    let settings = Settings(getterSetter: GetterSetterFake())
    let initialOrder = settings.sortOrder
    XCTAssertEqual(SortOrder.name, initialOrder)
    settings.sortOrder = .popularity
    XCTAssertEqual(settings.sortOrder, .popularity)
  }

  func testInitialization() {
    let 🦖 = "🦖"
    let 🪐 = "🪐"
    let getterSetter = GetterSetterFake(dictionary: [🦖: 🪐])
    XCTAssertEqual(getterSetter.get(key: 🦖), 🪐)
  }
}

42.
@testable import KatFancy
import XCTest

class GetterSetterRealTests: XCTestCase {
  func testGetAndSet() {
    let getterSetter = GetterSetterReal()
    let key = "key"
    let emptyValue = ""
    let actualValue = "🍕"
    getterSetter.set(key: key, value: emptyValue)
    XCTAssertEqual(emptyValue, getterSetter.get(key: key))
    getterSetter.set(key: key, value: actualValue)
    XCTAssertEqual(actualValue, getterSetter.get(key: key))
  }
}

43.
@testable import KatFancy
import XCTest

final class ImageLoaderTests: XCTestCase {
  func testFetch() async throws {
    guard let goodUrl = URL(string: MockData.photoUrlPrefix + MockData.breedNames[0] + MockData.mockPhotoExtension) else {
      XCTFail("Unable to initialize good photo URL.")
      return
    }

    let imageLoader = ImageLoader()
    var goodImage = await imageLoader.fetch(goodUrl)
    XCTAssertNotNil(goodImage)
    goodImage = await imageLoader.fetch(goodUrl)
    XCTAssertNotNil(goodImage)

    let expectedErrorImage = UIImage(resource: .error)

    guard let badUrl = URL(string: "https://racecondition.software") else {
      XCTFail("Unable to initialize bad photo URL.")
      return
    }

    let errorImage = await imageLoader.fetch(badUrl)
    XCTAssertNotNil(errorImage)

    XCTAssertEqual(errorImage.pngData(), expectedErrorImage.pngData())
  }

  func testSetSession() async {
    Current.settings.sessionType = .shared
    XCTAssertEqual(Current.settings.sessionType, .shared)
    Current.settings.sessionType = .stub
    XCTAssertEqual(Current.settings.sessionType, .stub)
  }
}

44.
@testable import KatFancy
import XCTest

final class SoundPlayerDummyTests: XCTestCase {
  func testPlay() {
    let soundPlayer = SoundPlayerDummy()
    soundPlayer.play(.chime)
    soundPlayer.play(.sadTrombone)
  }
}

45.
@testable import KatFancy
import XCTest

final class SoundPlayerRealTests: XCTestCase {
  func testPlay() {
    let soundPlayer = SoundPlayerReal()
    soundPlayer.play(.chime)
    soundPlayer.play(.sadTrombone)
  }
}

46.
@testable import KatFancy
import XCTest

class URLExtensionTests: XCTestCase {
  func testCouldNotInit() {
    let 🙀 = "🙀"
    XCTAssertEqual("Could not initialize URL from \(🙀).", URL.couldNotInit(urlString: 🙀))
  }
}

47.
@testable import KatFancy
import XCTest

class URLProtocolStubTests: XCTestCase {
  private static var backupURLDataDict = [URL: Data]()

  override class func setUp() {
    backupURLDataDict = URLSession.urlDataDict
  }

  override class func tearDown() {
    URLSession.urlDataDict = backupURLDataDict
  }

  private var url: URL {
    let urlString = "https://racecondition.software"
    if let url = URL(string: urlString) {
      return url
    } else {
      fatalError(URL.couldNotInit(urlString: urlString))
    }
  }

  private var request: URLRequest {
    URLRequest(url: url)
  }

  func testCanInit() {
    XCTAssert(URLProtocolStub.canInit(with: request))
  }

  func testCanonicalRequest() {
    XCTAssertEqual(request, URLProtocolStub.canonicalRequest(for: request))
  }

  func testStartLoading() {
    URLSession.urlDataDict = [url: Data()]
    let exp = expectation(description: "Waiting for load.")
    let protocolClientStub = ProtocolClientStub(didFinishLoading: { urlProtocol in
      XCTAssert(urlProtocol is URLProtocolStub)
      exp.fulfill()
    })
    let urlProtocolStub = URLProtocolStub(request: request, cachedResponse: nil, client: protocolClientStub)
    urlProtocolStub.startLoading()
    let timeout: TimeInterval = 1.0
    wait(for: [exp], timeout: timeout)
  }
}

private class ProtocolClientStub: NSObject, URLProtocolClient {
  let didFinishLoading: (URLProtocol) -> ()

  init(didFinishLoading: @escaping (URLProtocol) -> ()) {
    self.didFinishLoading = didFinishLoading
  }

  func urlProtocolDidFinishLoading(_ protocol: URLProtocol) {
    didFinishLoading(`protocol`)
  }

  func urlProtocol(_ protocol: URLProtocol, wasRedirectedTo request: URLRequest, redirectResponse: URLResponse) {}
  func urlProtocol(_ protocol: URLProtocol, cachedResponseIsValid cachedResponse: CachedURLResponse) {}
  func urlProtocol(_ protocol: URLProtocol, didReceive response: URLResponse, cacheStoragePolicy policy: URLCache.StoragePolicy) {}
  func urlProtocol(_ protocol: URLProtocol, didLoad data: Data) {}
  func urlProtocol(_ protocol: URLProtocol, didFailWithError error: Error) {}
  func urlProtocol(_ protocol: URLProtocol, didReceive challenge: URLAuthenticationChallenge) {}
  func urlProtocol(_ protocol: URLProtocol, didCancel challenge: URLAuthenticationChallenge) {}
}

48.
@testable import KatFancy
import XCTest

class URLSessionExtensionTests: XCTestCase {
  override class func setUp() {
    URLSession.didProcessURLs = false
  }

  override class func tearDown() {
    URLSession.didProcessURLs = false
  }

  func testStubData() {
    Current.settings.breedsURL = .withMore
    let session = URLSession.stub
    XCTAssert(session.configuration.protocolClasses?[0] is URLProtocolStub.Type)
    let expectedTestURLCount = MockData.breedNames.count + BreedsURL.allCases.count
    XCTAssertEqual(expectedTestURLCount, URLSession.urlDataDict.count)
  }
}

49.
@testable import KatFancy
import XCTest

class BreedsURLTests: XCTestCase {
  func testURL() {
    guard
      let expectedStandardURL = URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/breeds.json"),
      let expectedEmptyURL = URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/breeds_empty.json"),
      let expectedMalformedURL = URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/breeds_malformed.json"),
      let expectedWithMoreURL = URL(string: "https://assets.algoexpert.io/course-assets/iosexpert/breeds_with_more.json")
    else {
      XCTFail("Failed to initialize expected URL.")
      return
    }

    XCTAssertEqual(expectedStandardURL, BreedsURL.standard.url)
    XCTAssertEqual(expectedEmptyURL, BreedsURL.empty.url)
    XCTAssertEqual(expectedMalformedURL, BreedsURL.malformed.url)
    XCTAssertEqual(expectedWithMoreURL, BreedsURL.withMore.url)
  }

  func testDisplayName() {
    let expectedStandardDisplayName = "Standard"
    let expectedEmptyDisplayName = "Empty"
    let expectedMalformedDisplayName = "Malformed"
    let expectedWithMoreDisplayName = "With More"

    XCTAssertEqual(expectedStandardDisplayName, BreedsURL.standard.displayName)
    XCTAssertEqual(expectedEmptyDisplayName, BreedsURL.empty.displayName)
    XCTAssertEqual(expectedMalformedDisplayName, BreedsURL.malformed.displayName)
    XCTAssertEqual(expectedWithMoreDisplayName, BreedsURL.withMore.displayName)
  }
}

50.
static func == (lhs: Breed, rhs: Breed) -> Bool {
  lhs.name == rhs.name
}

51.
@testable import KatFancy
import XCTest

final class BreedTests: XCTestCase {
  func testEquality() async throws {
    let mockLeopard = MockData.breed
    let networkLeopard = try await BreedsLoader.loadBreeds()[0]
    XCTAssertEqual(mockLeopard, networkLeopard)
  }
}

52.
@testable import KatFancy
import XCTest

class LicenseTests: XCTestCase {
  func testURL() {
    [
      (License.cc1, "https://creativecommons.org/licenses/by-sa/1.0/"),
      (.cc2, "https://creativecommons.org/licenses/by-sa/2.0/"),
      (.cc3, "https://creativecommons.org/licenses/by-sa/3.0/"),
      (.cc4, "https://creativecommons.org/licenses/by-sa/4.0/"),
      (.ccnd2, "https://creativecommons.org/licenses/by-nd/2.0/"),
      (.pinterest, "https://policy.pinterest.com/en/terms-of-service"),
      (.publicDomain, "https://creativecommons.org/share-your-work/public-domain/")
    ].forEach {
      XCTAssertEqual("\($0.0.url)", $0.1)
    }
  }
}

53.
@testable import KatFancy
import XCTest

class SettingsTests: XCTestCase {
  func testBreedsURLSetting() {
    let settings = Settings(getterSetter: GetterSetterFake())
    XCTAssertEqual(Settings.breedsURLDefault, settings.breedsURL)
    XCTAssertEqual(BreedsURL.withMore, settings.breedsURL)
    settings.breedsURL = .withMore
    XCTAssertEqual(Settings.breedsURLDefault, settings.breedsURL)
    XCTAssertEqual(BreedsURL.withMore, settings.breedsURL)
    Current.settings.breedsURL = Settings.breedsURLDefault
  }

  func testSessionTypeSetting() {
    let settings = Settings(getterSetter: GetterSetterFake())
    XCTAssertEqual(Settings.sessionTypeDefault, settings.sessionType)
    XCTAssertEqual(SessionType.shared, settings.sessionType)
    settings.sessionType = .stub
    XCTAssertNotEqual(Settings.sessionTypeDefault, settings.sessionType)
    XCTAssertEqual(SessionType.stub, settings.sessionType)
    Current.settings.sessionType = Settings.sessionTypeDefault
  }

  func testSortOrderSetting() {
    let settings = Settings(getterSetter: GetterSetterFake())
    XCTAssertEqual(Settings.sortOrderDefault, settings.sortOrder)
    XCTAssertEqual(SortOrder.name, settings.sortOrder)
    settings.sortOrder = .popularity
    XCTAssertNotEqual(Settings.sortOrderDefault, settings.sortOrder)
    XCTAssertEqual(SortOrder.popularity, settings.sortOrder)
    Current.settings.sortOrder = Settings.sortOrderDefault
  }
}

54.
@testable import KatFancy
import XCTest

class SortOrderTests: XCTestCase {
  func testCompareTo() {
    let a = "A"
    let b = "B"

    let urlString = "https://racecondition.software"
    guard let url = URL(string: urlString) else {
      XCTFail(URL.couldNotInit(urlString: urlString))
      return
    }

    let breed1 = Breed(name: a, knownFor: "", popularity: 42, photoUrl: url, infoUrl: url, credit: "", license: .publicDomain, description: "")
    let breed2 = Breed(name: b, knownFor: "", popularity: 21, photoUrl: url, infoUrl: url, credit: "", license: .publicDomain, description: "")

    var sortOrder = SortOrder.name
    XCTAssert(sortOrder.compare(breed1: breed1, breed2: breed2))
    sortOrder = .popularity
    XCTAssertFalse(sortOrder.compare(breed1: breed1, breed2: breed2))
  }
}

55.
@testable import KatFancy
import XCTest

class WorldTests: XCTestCase {
  func testProductionWorld() {
    let world = World.production
    XCTAssert(world.settings.getterSetter is GetterSetterReal)
    XCTAssert(world.soundPlayer is SoundPlayerReal)
  }

  func testUnitTestWorld() {
    let world = World.unitTest
    XCTAssert(world.settings.getterSetter is GetterSetterFake)
    XCTAssert(world.soundPlayer is SoundPlayerDummy)
  }
}

56.
@testable import KatFancy
import XCTest

final class BrowseBreedsViewModelTests: XCTestCase {
  func testLoadBreeds() async {
    let vm = BrowseBreedsViewModel()

    let loadingState = vm.state
    XCTAssertEqual(loadingState, .loading)

    Current.settings.breedsURL = .withMore
    await vm.loadBreeds()
    let actualLoadedState = vm.state
    switch actualLoadedState {
    case .loading, .error:
      XCTFail("Unexpected state: \(actualLoadedState)")
      return
    case .loaded(let breeds):
      XCTAssertEqual(breeds.count, MockData.breedNames.count)
    }

    Current.settings.breedsURL = .malformed
    await vm.loadBreeds()
    let errorState = vm.state
    switch errorState {
    case .loading, .loaded:
      XCTFail("Unexpected state: \(errorState)")
      return
    case .error:
      break
    }

    Current.settings.breedsURL = .empty
    await vm.loadBreeds()
    let emptyLoadedState = vm.state
    switch emptyLoadedState {
    case .loading, .error:
      XCTFail("Unexpected state: \(emptyLoadedState)")
      return
    case .loaded(let breeds):
      XCTAssertEqual(breeds.count, 0)
    }

    Current.settings.breedsURL = .withMore
  }
}